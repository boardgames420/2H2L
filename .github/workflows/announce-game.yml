name: Announce Game

on:
  schedule:
    - cron: "*/5 * * * *"  # Every 5 minutes
  workflow_dispatch:

permissions:
  contents: write

jobs:
  assess_and_announce:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install jq and curl
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: Ensure results file exists
        run: |
          if [ ! -f results/games_results.json ]; then
            echo "results/games_results.json not found. Exiting."
            exit 0
          fi

      - name: Get latest poll message from channel
        id: fetch_message
        env:
          TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
          CHANNEL_ID: ${{ secrets.DISCORD_GAMES_CHANNEL_ID }}
        run: |
          set -euo pipefail
          RESPONSE=$(curl -s -H "Authorization: Bot $TOKEN" \
            "https://discord.com/api/v10/channels/$CHANNEL_ID/messages?limit=1")

          COUNT=$(echo "$RESPONSE" | jq 'length')
          if [ "$COUNT" -eq 0 ]; then
            echo "No messages in channel; exiting."
            echo "has_message=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "$RESPONSE" | jq '.[0]' > .poll_message.json
          MESSAGE_ID=$(jq -r '.id' .poll_message.json)
          if [ -z "$MESSAGE_ID" ] || [ "$MESSAGE_ID" = "null" ]; then
            echo "No valid latest message ID found; exiting."
            echo "has_message=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "MESSAGE_ID=$MESSAGE_ID" >> $GITHUB_ENV
          echo "has_message=true" >> "$GITHUB_OUTPUT"

      - name: Count unique voters (from actual message emojis)
        if: steps.fetch_message.outputs.has_message == 'true'
        env:
          TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
          CHANNEL_ID: ${{ secrets.DISCORD_GAMES_CHANNEL_ID }}
        run: |
          set -euo pipefail

          # The poll message was constructed with A..Z regional indicator emojis.
          EMOJIS=(ðŸ‡¦ ðŸ‡§ ðŸ‡¨ ðŸ‡© ðŸ‡ª ðŸ‡« ðŸ‡¬ ðŸ‡­ ðŸ‡® ðŸ‡¯ ðŸ‡° ðŸ‡± ðŸ‡² ðŸ‡³ ðŸ‡´ ðŸ‡µ ðŸ‡¶ ðŸ‡· ðŸ‡¸ ðŸ‡¹ ðŸ‡º ðŸ‡» ðŸ‡¼ ðŸ‡½ ðŸ‡¾ ðŸ‡¿)

          # Detect exactly which emojis are present in the posted poll message.
          CONTENT=$(jq -r '.content' .poll_message.json | tr -d '\r')
          printf "%s\n" "$CONTENT" > .poll_message_content.txt

          : > .used_emojis.txt
          for E in "${EMOJIS[@]}"; do
            # Matches lines like: "ðŸ‡¦ Game Title"
            if grep -q "^$E " .poll_message_content.txt; then
              echo "$E" >> .used_emojis.txt
            fi
          done

          if [ ! -s .used_emojis.txt ]; then
            echo "No recognizable poll emojis found in message; exiting."
            echo "UNIQUE_VOTERS=0" >> $GITHUB_ENV
            exit 0
          fi

          : > .all_voters.txt

          # Fetch reactors for each actually used emoji from the message (ignore bot users)
          while read -r EMOJI; do
            [ -z "$EMOJI" ] && continue
            ENCODED=$(printf "%s" "$EMOJI" | jq -sRr @uri)

            USERS_RESPONSE=$(curl -s -H "Authorization: Bot $TOKEN" \
              "https://discord.com/api/v10/channels/$CHANNEL_ID/messages/$MESSAGE_ID/reactions/$ENCODED?limit=100")

            echo "$USERS_RESPONSE" | jq -r '.[] | select(.bot != true) | .id' >> .all_voters.txt || true
          done < .used_emojis.txt

          if [ -s .all_voters.txt ]; then
            sort -u .all_voters.txt > .all_voters_uniq.txt
            UNIQUE_VOTERS=$(wc -l < .all_voters_uniq.txt | tr -d '[:space:]')
          else
            UNIQUE_VOTERS=0
          fi

          echo "UNIQUE_VOTERS=${UNIQUE_VOTERS}" >> $GITHUB_ENV
          echo "Unique voters detected: ${UNIQUE_VOTERS}"

          # If nobody voted, stop here quietly
          if [ "$UNIQUE_VOTERS" -eq 0 ]; then
            echo "No voters yet; exiting."
            exit 0
          fi

      - name: Choose a playable winner and announce
        if: steps.fetch_message.outputs.has_message == 'true'
        env:
          TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
          CHANNEL_ID: ${{ secrets.DISCORD_GAMES_CHANNEL_ID }}
        run: |
          set -euo pipefail

          # Helper: get min/max players from a game JSON file.
          # Supports:
          # - minPlayers/maxPlayers or players_min/players_max
          # - players: "1-4", "1â€“4", "1 to 4" (parsed)
          get_minmax() {
            local file="$1"
            local MIN MAX

            MIN=$(jq -r '(.minPlayers // .players_min // empty)' "$file")
            MAX=$(jq -r '(.maxPlayers // .players_max // empty)' "$file")

            if [ -z "$MIN" ] || [ "$MIN" = "null" ] || [ -z "$MAX" ] || [ "$MAX" = "null" ]; then
              local PSTR
              PSTR=$(jq -r '(.players // empty)' "$file")
              if [ -n "$PSTR" ] && [ "$PSTR" != "null" ]; then
                MIN=$(printf "%s" "$PSTR" | grep -Eo '[0-9]+' | sed -n '1p')
                MAX=$(printf "%s" "$PSTR" | grep -Eo '[0-9]+' | sed -n '2p')
              fi
            fi

            echo "${MIN:-}" "${MAX:-}"
          }

          UNIQUE_VOTERS="${UNIQUE_VOTERS:-0}"
          echo "Evaluating with UNIQUE_VOTERS=${UNIQUE_VOTERS}"

          # Sort by votes desc and scan for the first that fits UNIQUE_VOTERS
          jq -c '.votes | sort_by(-.votes)' results/games_results.json > .votes_sorted.json

          CHOSEN_SLUG=""
          CHOSEN_TITLE=""
          CHOSEN_URL=""
          CHOSEN_MIN=""
          CHOSEN_MAX=""
          CHOSEN_VOTES=""
          FOUND=0

          while read -r ROW; do
            SLUG=$(echo "$ROW" | jq -r '.slug')
            TITLE=$(echo "$ROW" | jq -r '.title')
            URL=$(echo "$ROW" | jq -r '.url')
            VOTES=$(echo "$ROW" | jq -r '.votes')

            GAME_FILE="games/${SLUG}.json"
            if [ ! -f "$GAME_FILE" ]; then
              continue
            fi

            read MIN MAX < <(get_minmax "$GAME_FILE")

            # Require both MIN and MAX; skip if missing
            if [ -z "$MIN" ] || [ -z "$MAX" ]; then
              continue
            fi

            if [ "$UNIQUE_VOTERS" -ge "$MIN" ] && [ "$UNIQUE_VOTERS" -le "$MAX" ]; then
              CHOSEN_SLUG="$SLUG"
              CHOSEN_TITLE="$TITLE"
              CHOSEN_URL="$URL"
              CHOSEN_MIN="$MIN"
              CHOSEN_MAX="$MAX"
              CHOSEN_VOTES="$VOTES"
              FOUND=1
              break
            fi
          done < <(jq -c '.[]' .votes_sorted.json)

          if [ "$FOUND" -eq 1 ]; then
            echo "CHOSEN_SLUG=$CHOSEN_SLUG" >> $GITHUB_ENV
            echo "CHOSEN_TITLE=$CHOSEN_TITLE" >> $GITHUB_ENV
            echo "CHOSEN_URL=$CHOSEN_URL" >> $GITHUB_ENV
            echo "CHOSEN_MIN=$CHOSEN_MIN" >> $GITHUB_ENV
            echo "CHOSEN_MAX=$CHOSEN_MAX" >> $GITHUB_ENV
            echo "CHOSEN_VOTES=$CHOSEN_VOTES" >> $GITHUB_ENV
            echo "NO_SUITABLE=false" >> $GITHUB_ENV
          else
            echo "No suitable game found for ${UNIQUE_VOTERS} players."
            echo "NO_SUITABLE=true" >> $GITHUB_ENV
          fi

      - name: Post announcement to Discord (winner)
        if: env.NO_SUITABLE == 'false' && env.CHOSEN_SLUG != ''
        env:
          TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
          CHANNEL_ID: ${{ secrets.DISCORD_GAMES_CHANNEL_ID }}
          TITLE: ${{ env.CHOSEN_TITLE }}
          URL: ${{ env.CHOSEN_URL }}
          MINP: ${{ env.CHOSEN_MIN }}
          MAXP: ${{ env.CHOSEN_MAX }}
          VOTES: ${{ env.CHOSEN_VOTES }}
          NPLAYERS: ${{ env.UNIQUE_VOTERS }}
        run: |
          set -euo pipefail
          MSG="âœ… **Winner fits the table!**\n\n**${TITLE}** (${URL})\nPlayers: ${MINP}-${MAXP}\nVotes: ${VOTES}\nConfirmed players (unique voters): ${NPLAYERS}"
          JSON=$(jq -Rn --arg c "$MSG" '{content:$c}')

          curl -s -X POST "https://discord.com/api/v10/channels/$CHANNEL_ID/messages" \
            -H "Authorization: Bot $TOKEN" \
            -H "Content-Type: application/json" \
            -d "$JSON" >/dev/null

      - name: Post announcement to Discord (no suitable game)
        if: env.NO_SUITABLE == 'true'
        env:
          TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
          CHANNEL_ID: ${{ secrets.DISCORD_GAMES_CHANNEL_ID }}
          NPLAYERS: ${{ env.UNIQUE_VOTERS }}
        run: |
          set -euo pipefail
          MSG="âš ï¸ No polled game currently fits **${NPLAYERS}** confirmed players. Consider adjusting players or proposing an alternative."
          JSON=$(jq -Rn --arg c "$MSG" '{content:$c}')

          curl -s -X POST "https://discord.com/api/v10/channels/$CHANNEL_ID/messages" \
            -H "Authorization: Bot $TOKEN" \
            -H "Content-Type: application/json" \
            -d "$JSON" >/dev/null
