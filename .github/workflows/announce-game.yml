name: Announce Game

on:
  schedule:
    - cron: "*/5 * * * *"  # Check every 5 minutes
  workflow_dispatch:

permissions:
  contents: write

jobs:
  assess_and_announce:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install jq and curl
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: Load event info (date/time/playersLimit)
        id: load_event
        run: |
          set -euo pipefail
          EVENT_DATE=$(jq -r '.date // empty' events/upcoming.json 2>/dev/null || true)
          EVENT_TIME=$(jq -r '.time // empty' events/upcoming.json 2>/dev/null || true)
          PLAYERS_LIMIT=$(jq -r '.playersLimit // empty' events/upcoming.json 2>/dev/null || true)
          echo "EVENT_DATE=$EVENT_DATE" >> $GITHUB_ENV
          echo "EVENT_TIME=$EVENT_TIME" >> $GITHUB_ENV
          echo "PLAYERS_LIMIT=$PLAYERS_LIMIT" >> $GITHUB_ENV

      - name: Gate â€” only at 17:00 Europe/Rome on event day and not already announced
        id: gate
        run: |
          set -euo pipefail

          EVENT_DATE="${EVENT_DATE:-}"
          if [ -z "$EVENT_DATE" ] || [ "$EVENT_DATE" = "null" ]; then
            echo "No EVENT_DATE in events/upcoming.json; exiting."
            echo "should_post=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          TODAY_LOCAL=$(TZ=Europe/Rome date +%F)
          HOUR_LOCAL=$(TZ=Europe/Rome date +%H)
          echo "Event date:     $EVENT_DATE"
          echo "Today (local):  $TODAY_LOCAL"
          echo "Hour  (local):  $HOUR_LOCAL"

          if [ "$TODAY_LOCAL" != "$EVENT_DATE" ]; then
            echo "Not the event day. Skipping."
            echo "should_post=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ "$HOUR_LOCAL" != "17" ]; then
            echo "Not 17:00 local yet. Skipping."
            echo "should_post=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          RECORD_FILE=".last_game_announcement"
          if [ -f "$RECORD_FILE" ] && grep -qx "$EVENT_DATE" "$RECORD_FILE"; then
            echo "Already announced for $EVENT_DATE. Skipping."
            echo "should_post=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Time gate passed â€” we should post."
          echo "should_post=true" >> "$GITHUB_OUTPUT"

      - name: Exit if not time to post
        if: steps.gate.outputs.should_post != 'true'
        run: exit 0

      - name: Ensure results file exists (needed to pick winner)
        run: |
          if [ ! -f results/games_results.json ]; then
            echo "results/games_results.json not found. Exiting."
            exit 0
          fi

      - name: Find latest poll message in channel
        id: fetch_message
        env:
          TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
          CHANNEL_ID: ${{ secrets.DISCORD_GAMES_CHANNEL_ID }}
        run: |
          set -euo pipefail
          RESPONSE=$(curl -s -H "Authorization: Bot $TOKEN" \
            "https://discord.com/api/v10/channels/$CHANNEL_ID/messages?limit=50")
          POLL=$(echo "$RESPONSE" | jq -c '[.[] | select((.content // "") | contains("React with the emoji to vote:"))] | first')
          if [ "$POLL" = "null" ] || [ -z "$POLL" ]; then
            POLL=$(echo "$RESPONSE" | jq -c '[.[] | select((.content // "") | contains("Vote for the week"))] | first')
          fi
          if [ "$POLL" = "null" ] || [ -z "$POLL" ]; then
            echo "Could not find a recent poll message. Exiting."
            echo "has_message=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "$POLL" | jq '.' > .poll_message.json
          MESSAGE_ID=$(jq -r '.id' .poll_message.json)
          if [ -z "$MESSAGE_ID" ] || [ "$MESSAGE_ID" = "null" ]; then
            echo "No valid poll message ID found; exiting."
            echo "has_message=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "MESSAGE_ID=$MESSAGE_ID" >> $GITHUB_ENV
          echo "has_message=true" >> "$GITHUB_OUTPUT"

      - name: Count unique voters (strict Aâ€“Z + fallback all-reactions, with diagnostics)
        if: steps.fetch_message.outputs.has_message == 'true'
        env:
          TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
          CHANNEL_ID: ${{ secrets.DISCORD_GAMES_CHANNEL_ID }}
          DISCORD_BOT_USER_ID: ${{ secrets.DISCORD_BOT_USER_ID }}
        run: |
          set -euo pipefail

          mkdir -p debug
          echo "Polling reactions from message $MESSAGE_ID in channel $CHANNEL_ID"

          # Emoji sul messaggio (tutte)
          jq -r '.reactions[]? | .emoji.name' .poll_message.json | sort -u > debug.reactions.all_emoji.txt || true
          echo "Emojis on message:"; cat debug.reactions.all_emoji.txt || true

          # Whitelist Aâ€“Z (regional indicators)
          EMOJIS=(ðŸ‡¦ ðŸ‡§ ðŸ‡¨ ðŸ‡© ðŸ‡ª ðŸ‡« ðŸ‡¬ ðŸ‡­ ðŸ‡® ðŸ‡¯ ðŸ‡° ðŸ‡± ðŸ‡² ðŸ‡³ ðŸ‡´ ðŸ‡µ ðŸ‡¶ ðŸ‡· ðŸ‡¸ ðŸ‡¹ ðŸ‡º ðŸ‡» ðŸ‡¼ ðŸ‡½ ðŸ‡¾ ðŸ‡¿)
          : > debug.reactions.used_letters.txt
          for E in "${EMOJIS[@]}"; do
            grep -Fxq "$E" debug.reactions.all_emoji.txt && echo "$E" >> debug.reactions.used_letters.txt
          done
          echo "A-Z emojis detected:"; cat debug.reactions.used_letters.txt || true

          # Funzione per scaricare TUTTI gli utenti (con paginazione) di una reaction
          fetch_users_for_emoji() {
            local emoji="$1"
            local encoded; encoded=$(printf "%s" "$emoji" | jq -sRr @uri)
            local after=""
            local tmp; tmp=$(mktemp)

            : > "$tmp"
            while : ; do
              local url="https://discord.com/api/v10/channels/$CHANNEL_ID/messages/$MESSAGE_ID/reactions/$encoded?limit=100"
              [ -n "$after" ] && url="${url}&after=${after}"
              local page; page=$(mktemp)
              local code
              code=$(curl -sS -o "$page" -w "%{http_code}" -H "Authorization: Bot $TOKEN" "$url" || true)
              if [ "$code" -ge 200 ] && [ "$code" -lt 300 ]; then
                cat "$page" >> "$tmp"
                local n; n=$(jq 'length' "$page")
                if [ "$n" -lt 100 ]; then
                  break
                else
                  after=$(jq -r '.[-1].id' "$page")
                fi
              else
                echo "âš ï¸  Fetch failed for emoji [$emoji] HTTP $code" >&2
                break
              fi
            done

            # Ritorna via stdout la lista di ID (uno per riga), filtrando bot e il bot stesso
            jq -r --arg bot "${DISCORD_BOT_USER_ID:-}" '
              .[]? | select(.bot != true and (.id != $bot)) | .id
            ' "$tmp"
          }

          # --- ModalitÃ  STRICT: solo Aâ€“Z ---
          : > debug/ids_letters_raw.txt
          if [ -s debug.reactions.used_letters.txt ]; then
            while read -r EM; do
              [ -z "$EM" ] && continue
              echo "Fetching users for letter: $EM"
              fetch_users_for_emoji "$EM" | tee -a debug/ids_letters_raw.txt >/dev/null
            done < debug.reactions.used_letters.txt
          fi
          sort -u debug/ids_letters_raw.txt > debug/ids_letters_unique.txt || true
          COUNT_LETTERS=$(wc -l < debug/ids_letters_unique.txt | tr -d '[:space:]')
          echo "Strict Aâ€“Z unique voters: $COUNT_LETTERS"

          # --- ModalitÃ  ALL: tutte le emoji presenti (escluso bot) ---
          : > debug/ids_all_raw.txt
          if [ -s debug.reactions.all_emoji.txt ]; then
            while read -r EM; do
              [ -z "$EM" ] && continue
              echo "Fetching users for emoji: $EM"
              fetch_users_for_emoji "$EM" | tee -a debug/ids_all_raw.txt >/dev/null
            done < debug.reactions.all_emoji.txt
          fi
          sort -u debug/ids_all_raw.txt > debug/ids_all_unique.txt || true
          COUNT_ALL=$(wc -l < debug/ids_all_unique.txt | tr -d '[:space:]')
          echo "All-reactions unique voters: $COUNT_ALL"

          # --- Scelta del conteggio da usare ---
          # Se ALL > LETTERS, probabilmente qualcuno ha votato con ðŸ…°ï¸/1ï¸âƒ£/âœ… ecc.
          if [ "$COUNT_ALL" -gt "$COUNT_LETTERS" ]; then
            echo "UNIQUE_VOTERS=${COUNT_ALL}" >> $GITHUB_ENV
            cp debug/ids_all_unique.txt debug/ids_final_unique.txt
            echo "Using ALL reactions count ($COUNT_ALL)."
          else
            echo "UNIQUE_VOTERS=${COUNT_LETTERS}" >> $GITHUB_ENV
            cp debug/ids_letters_unique.txt debug/ids_final_unique.txt
            echo "Using Aâ€“Z reactions count ($COUNT_LETTERS)."
          fi

          echo "==== Diagnostics ===="
          echo "DISCORD_BOT_USER_ID=${DISCORD_BOT_USER_ID:-<unset>}"
          echo "Emojis on message:"; cat debug.reactions.all_emoji.txt || true
          echo "A-Z emojis used:"; cat debug.reactions.used_letters.txt || true
          echo "IDs (Aâ€“Z, unique):"; cat debug/ids_letters_unique.txt || true
          echo "IDs (ALL, unique):"; cat debug/ids_all_unique.txt || true
          echo "IDs (FINAL, unique):"; cat debug/ids_final_unique.txt || true


      - name: Choose a playable winner and set env
        if: steps.fetch_message.outputs.has_message == 'true'
        run: |
          set -euo pipefail
          get_minmax() {
            local file="$1"; local MIN MAX
            MIN=$(jq -r '(.minPlayers // .players_min // empty)' "$file")
            MAX=$(jq -r '(.maxPlayers // .players_max // empty)' "$file")
            if [ -z "$MIN" ] || [ "$MIN" = "null" ] || [ -z "$MAX" ] || [ "$MAX" = "null" ]; then
              local PSTR; PSTR=$(jq -r '(.players // empty)' "$file")
              if [ -n "$PSTR" ] && [ "$PSTR" != "null" ]; then
                MIN=$(printf "%s" "$PSTR" | grep -Eo '[0-9]+' | sed -n '1p')
                MAX=$(printf "%s" "$PSTR" | grep -Eo '[0-9]+' | sed -n '2p')
              fi
            fi
            echo "${MIN:-}" "${MAX:-}"
          }
          UNIQUE_VOTERS="${UNIQUE_VOTERS:-0}"
          jq -c '.votes | sort_by(-.votes)' results/games_results.json > .votes_sorted.json
          CHOSEN_SLUG=""; CHOSEN_TITLE=""; CHOSEN_URL=""; CHOSEN_MIN=""; CHOSEN_MAX=""; CHOSEN_VOTES=""; FOUND=0
          while read -r ROW; do
            SLUG=$(echo "$ROW" | jq -r '.slug'); TITLE=$(echo "$ROW" | jq -r '.title')
            URL=$(echo "$ROW" | jq -r '.url'); VOTES=$(echo "$ROW" | jq -r '.votes')
            GAME_FILE="games/${SLUG}.json"; [ -f "$GAME_FILE" ] || continue
            read MIN MAX < <(get_minmax "$GAME_FILE"); [ -n "$MIN" ] && [ -n "$MAX" ] || continue
            if [ "$UNIQUE_VOTERS" -ge "$MIN" ] && [ "$UNIQUE_VOTERS" -le "$MAX" ]; then
              CHOSEN_SLUG="$SLUG"; CHOSEN_TITLE="$TITLE"; CHOSEN_URL="$URL"; CHOSEN_MIN="$MIN"; CHOSEN_MAX="$MAX"; CHOSEN_VOTES="$VOTES"; FOUND=1; break
            fi
          done < <(jq -c '.[]' .votes_sorted.json)
          if [ "$FOUND" -eq 1 ]; then
            echo "CHOSEN_SLUG=$CHOSEN_SLUG" >> $GITHUB_ENV
            echo "CHOSEN_TITLE=$CHOSEN_TITLE" >> $GITHUB_ENV
            echo "CHOSEN_URL=$CHOSEN_URL" >> $GITHUB_ENV
            echo "CHOSEN_MIN=$CHOSEN_MIN" >> $GITHUB_ENV
            echo "CHOSEN_MAX=$CHOSEN_MAX" >> $GITHUB_ENV
            echo "CHOSEN_VOTES=$CHOSEN_VOTES" >> $GITHUB_ENV
            echo "NO_SUITABLE=false" >> $GITHUB_ENV
          else
            echo "NO_SUITABLE=true" >> $GITHUB_ENV
          fi

      - name: Post announcement to Discord (single message, with limit if present)
        if: env.NO_SUITABLE == 'false' && env.CHOSEN_SLUG != ''
        env:
          TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
          CHANNEL_ID: ${{ secrets.DISCORD_GAMES_CHANNEL_ID }}
          TITLE: ${{ env.CHOSEN_TITLE }}
          EDATE: ${{ env.EVENT_DATE }}
          ETIME: ${{ env.EVENT_TIME }}
          NPLAYERS: ${{ env.UNIQUE_VOTERS }}
          PLIMIT: ${{ env.PLAYERS_LIMIT }}
        run: |
          set -euo pipefail

          # Righe messaggio
          TITLE_LINE="**${TITLE}**"
          DATE_LINE="Data e ora: ${EDATE} ${ETIME}"

          if [ -n "${PLIMIT}" ] && [ "${PLIMIT}" != "null" ]; then
            PLAYERS_LINE="Numero di Giocatori: ${NPLAYERS}/${PLIMIT}"
          else
            PLAYERS_LINE="Numero di Giocatori: ${NPLAYERS}"
          fi

          printf "%s\n%s\n%s\n" "$TITLE_LINE" "$DATE_LINE" "$PLAYERS_LINE" > announce_winner.txt
          MSG_CONTENT=$(jq -Rs . < announce_winner.txt | sed 's/\\\\n/\\n/g')

          RESP_BODY=$(mktemp)
          HTTP_CODE=$(curl -sS -o "$RESP_BODY" -w "%{http_code}" -X POST \
            "https://discord.com/api/v10/channels/$CHANNEL_ID/messages" \
            -H "Authorization: Bot $TOKEN" \
            -H "Content-Type: application/json" \
            -d "{\"content\": $MSG_CONTENT}" || true)

          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            # Mark announced only on success
            echo "$EDATE" > .last_game_announcement
            git config --global user.name "github-actions[bot]"
            git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add .last_game_announcement
            git commit -m "Record game announcement for ${EDATE}" || echo "No changes"
            git push || echo "Nothing to push"
          else
            echo "Post failed with HTTP $HTTP_CODE"
            cat "$RESP_BODY" || true
            exit 1
          fi
