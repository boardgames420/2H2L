name: Collect Games Poll Reactions

on:
  schedule:
    - cron: "*/5 * * * *" # Every 5 minutes
  workflow_dispatch:

permissions:
  contents: write

jobs:
  collect_votes:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install jq and curl
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: Get latest poll message from channel
        id: fetch_message
        env:
          TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
          CHANNEL_ID: ${{ secrets.DISCORD_GAMES_CHANNEL_ID }}
        run: |
          set -euo pipefail
          RESPONSE=$(curl -s -H "Authorization: Bot $TOKEN" \
            "https://discord.com/api/v10/channels/$CHANNEL_ID/messages?limit=1")

          # If there are no messages, bail gracefully
          COUNT=$(echo "$RESPONSE" | jq 'length')
          if [ "$COUNT" -eq 0 ]; then
            echo "No messages in channel; exiting."
            exit 0
          fi

          MESSAGE_ID=$(echo "$RESPONSE" | jq -r '.[0].id')
          if [ -z "$MESSAGE_ID" ] || [ "$MESSAGE_ID" = "null" ]; then
            echo "No latest message ID found; exiting."
            exit 0
          fi

          echo "MESSAGE_ID=$MESSAGE_ID" >> $GITHUB_ENV
          echo "$RESPONSE" | jq '.[0]' > .poll_message.json

      - name: Generate results (robust)
        run: |
          set -euo pipefail
          export LC_ALL=C.UTF-8
          export LANG=C.UTF-8

          mkdir -p results/games

          # Mappa fissa Aâ€“Z (max 26 opzioni)
          declare -a EMOJIS=(ðŸ‡¦ ðŸ‡§ ðŸ‡¨ ðŸ‡© ðŸ‡ª ðŸ‡« ðŸ‡¬ ðŸ‡­ ðŸ‡® ðŸ‡¯ ðŸ‡° ðŸ‡± ðŸ‡² ðŸ‡³ ðŸ‡´ ðŸ‡µ ðŸ‡¶ ðŸ‡· ðŸ‡¸ ðŸ‡¹ ðŸ‡º ðŸ‡» ðŸ‡¼ ðŸ‡½ ðŸ‡¾ ðŸ‡¿)

          # Reactions "emoji count" dalla poll message (se non ci sono reactions, il file resta vuoto)
          jq -r '.reactions[]? | "\(.emoji.name) \(.count)"' .poll_message.json > .reaction_counts.txt || true

          NOW=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          TODAY=$(date -u +'%Y-%m-%d')

          # Filtra giochi: presenti tra i proprietari + non comingSoon, altrimenti solo non comingSoon
          if [ -f results/owners_results.json ]; then
            jq -n \
              --slurpfile games games/index.json \
              --slurpfile owners results/owners_results.json \
              '$games[0]
               | map(select(.owner as $o | $owners[0].present | index($o))
                     | select(.comingSoon != true))' > .filtered_games.json
          else
            jq '[ .[] | select(.comingSoon != true) ]' games/index.json > .filtered_games.json
          fi

          TOTAL=$(jq 'length' .filtered_games.json)
          if [ "$TOTAL" -eq 0 ]; then
            echo "No eligible games after filtering; exiting."
            exit 0
          fi

          # Limita a 26 voci (quante le emoji disponibili). Se ne hai di piÃ¹, tronca con avviso.
          if [ "$TOTAL" -gt 26 ]; then
            echo "âš ï¸  There are $TOTAL games; trimming to first 26 to match Aâ€“Z."
            jq '.[0:26]' .filtered_games.json > .filtered_games_26.json
            mv .filtered_games_26.json .filtered_games.json
            TOTAL=26
          fi

          # Costruisci results/games_results.json
          {
            echo "{"
            echo "  \"votes\": ["
          } > results/games_results.json

          i=0
          first=1

          # Usa process substitution (no subshell) per non perdere lo stato di i se mai servisse
          while read -r SLUG; do
            [ -z "$SLUG" ] && continue
            GAME_JSON="games/${SLUG}.json"

            if [ ! -f "$GAME_JSON" ]; then
              echo "âš ï¸  Missing $GAME_JSON, skipping." >&2
              continue
            fi

            # Estrai con fallback a stringhe vuote, senza far fallire jq
            TITLE=$(jq -r '.title // empty' "$GAME_JSON" 2>/dev/null || echo "")
            URL=$(jq -r '.url // empty' "$GAME_JSON" 2>/dev/null || echo "")

            if [ -z "$TITLE" ]; then
              echo "âš ï¸  $GAME_JSON has no .title, skipping." >&2
              continue
            fi

            # Emoji per questo indice
            EMOJI="${EMOJIS[$i]:-}"
            if [ -z "$EMOJI" ]; then
              echo "âš ï¸  No emoji for index $i (out of Aâ€“Z), skipping remaining." >&2
              break
            fi

            # Conta le reactions per quellâ€™emoji (se non câ€™Ã¨, 0)
            RAW=$(grep -F -- "$EMOJI " .reaction_counts.txt | awk '{print $2}' || true)
            VOTES=${RAW:-0}

            # Sottrai la reaction del bot se il bot reagisce con le sue emoji
            if [ "$VOTES" -gt 0 ]; then VOTES=$((VOTES - 1)); fi

            if [ $first -eq 0 ]; then
              echo "," >> results/games_results.json
            fi
            first=0

            # Scrivi entry
            printf '    {"slug": "%s", "title": "%s", "url": "%s", "votes": %s}' \
              "$SLUG" "$TITLE" "$URL" "$VOTES" >> results/games_results.json

            i=$((i + 1))
          done < <(jq -r '.[].slug' .filtered_games.json)

          {
            echo ""
            echo "  ],"
            echo "  \"generatedAt\": \"${NOW}\""
            echo "}"
          } >> results/games_results.json

          cp results/games_results.json "results/games/${TODAY}.json"


      - name: Commit results
        run: |
          set -euo pipefail
          git config --global user.name "poll-bot"
          git config --global user.email "bot@example.com"
          git add results/games_results.json results/games/*.json
          git commit -m "Update game poll results and archive" || echo "No changes to commit."
          git push || echo "Nothing to push."
